<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Trading Simulator</title>
    <script src="https://cdn.jsdelivr.net/npm/danfojs@1.1.2/lib/bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg-color: #f4f4f9;
            --text-color: #333;
            --container-bg: white;
            --card-bg: #ecf0f1;
            --header-color: #2c3e50;
            --table-header-bg: #3498db;
            --table-row-hover: #f1f1f1;
            --table-border: #ddd;
            --accent-color: #3498db;
        }
        [data-theme="dark"] {
            --bg-color: #1a1a1a;
            --text-color: #f4f4f4;
            --container-bg: #2d2d2d;
            --card-bg: #3d3d3d;
            --header-color: #ecf0f1;
            --table-header-bg: #2980b9;
            --table-row-hover: #3d3d3d;
            --table-border: #444;
            --accent-color: #5dade2;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }
        h1, h2 { color: var(--header-color); }
        .container {
            max-width: 1300px;
            width: 100%;
            margin: auto;
            background: var(--container-bg);
            padding: 20px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            border-radius: 8px;
            position: relative;
            box-sizing: border-box;
        }
        .theme-toggle {
            position: absolute; top: 20px; right: 20px; background: none; border: none;
            cursor: pointer; font-size: 24px; color: var(--text-color);
            display: flex; align-items: center; justify-content: center;
            width: 40px; height: 40px; border-radius: 50%; transition: background 0.3s;
        }
        .theme-toggle:hover { background: var(--card-bg); }
        .theme-toggle svg { width: 24px; height: 24px; fill: currentColor; }
        .controls {
            display: flex; gap: 20px; flex-wrap: wrap; align-items: flex-end;
            margin-bottom: 20px; background: var(--card-bg); padding: 15px; border-radius: 8px;
        }
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        select, input {
            padding: 8px; border-radius: 5px; background: var(--container-bg);
            color: var(--text-color); border: 1px solid var(--table-border);
        }
        .stats {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px; margin-bottom: 20px;
        }
        .stat-card { background: var(--card-bg); padding: 15px; border-radius: 5px; text-align: center; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { text-align: left; padding: 12px; border-bottom: 1px solid var(--table-border); }
        th { background-color: var(--table-header-bg); color: white; }
        tr:hover { background-color: var(--table-row-hover); }
        #chart-wrapper { width: 100%; height: 500px; margin: 20px 0; }
        #game-container { display: none; text-align: center; margin-top: 40px; }
        #flappyCanvas { border: 2px solid #333; background-color: #70c5ce; display: block; margin: 20px auto; }
        .btn {
            background-color: #27ae60; color: white; padding: 10px 20px; border: none;
            border-radius: 5px; cursor: pointer; font-size: 16px;
        }
        .btn:hover { background-color: #2ecc71; }
        .btn-secret { background-color: #e74c3c; margin-top: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <button class="theme-toggle" id="theme-toggle" title="Toggle Dark Mode">
            <svg id="theme-icon" viewBox="0 0 24 24"><path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.99 4.58a.996.996 0 00-1.41 0 .996.996 0 000 1.41l1.06 1.06c.39.39 1.03.39 1.41 0s.39-1.03 0-1.41L5.99 4.58zm12.37 12.37a.996.996 0 00-1.41 0 .996.996 0 000 1.41l1.06 1.06c.39.39 1.03.39 1.41 0s.39-1.03 0-1.41l-1.06-1.06zm1.06-10.96a.996.996 0 000-1.41.996.996 0 00-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06zM7.05 18.36a.996.996 0 000-1.41.996.996 0 00-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06z"/></svg>
        </button>
        <h1>Crypto Trading Simulation</h1>

        <div class="controls">
            <div class="control-group">
                <label for="crypto-select">Cryptocurrency:</label>
                <select id="crypto-select">
                    <option value="bitcoin">Bitcoin (BTC)</option>
                    <option value="ethereum">Ethereum (ETH)</option>
                    <option value="binancecoin">BNB</option>
                    <option value="solana">Solana (SOL)</option>
                    <option value="ripple">XRP</option>
                    <option value="dogecoin">Dogecoin (DOGE)</option>
                    <option value="cardano">Cardano (ADA)</option>
                    <option value="avalanche-2">Avalanche (AVAX)</option>
                    <option value="tron">TRON (TRX)</option>
                    <option value="polkadot">Polkadot (DOT)</option>
                </select>
            </div>
            <div class="control-group">
                <label for="strategy-select">Strategy:</label>
                <select id="strategy-select">
                    <optgroup label="Trend Following (Long)">
                        <option value="golden_cross">Golden Cross (7/30 MA)</option>
                        <option value="ema_cross">EMA Cross (12/26)</option>
                        <option value="sma_cross">SMA Cross (50/200)</option>
                    </optgroup>
                    <optgroup label="Momentum (Long)">
                        <option value="rsi">RSI (Relative Strength Index)</option>
                        <option value="macd">MACD Momentum</option>
                        <option value="stochastic">Stochastic Oscillator</option>
                        <option value="williams_r">Williams %R</option>
                    </optgroup>
                    <optgroup label="Mean Reversion (Long)">
                        <option value="bollinger">Bollinger Bands</option>
                        <option value="mean_reversion">Mean Reversion (MA 20)</option>
                        <option value="cci">Commodity Channel Index (CCI)</option>
                    </optgroup>
                    <optgroup label="Short Strategies (Profit from Drops)">
                        <option value="short_rsi">Inverse RSI Short</option>
                        <option value="short_macd">MACD Bearish Short</option>
                    </optgroup>
                </select>
            </div>
            <div class="control-group">
                <label for="mode-select">Simulation Mode:</label>
                <select id="mode-select">
                    <option value="USD">Maximize Dollar Profit ($)</option>
                    <option value="ACCUMULATE">Stack Assets (Accumulation)</option>
                </select>
            </div>
            <div class="control-group">
                <label for="period-input">Period (Days):</label>
                <input type="number" id="period-input" value="60" min="10" max="330">
            </div>
            <div class="control-group">
                <label for="balance-input" id="balance-label">Initial Balance ($):</label>
                <input type="number" id="balance-input" value="100000" min="0.00001">
            </div>
        </div>

        <div id="strategy-info" style="margin-bottom: 20px; padding: 15px; background: var(--card-bg); border-radius: 5px; font-size: 0.9em;">
            <!-- Strategy summary will be injected here -->
        </div>

        <div id="performance-summary" class="stats">
            <!-- Summary will be injected here -->
        </div>

        <div id="chart-wrapper">
            <canvas id="priceChart"></canvas>
        </div>

        <div id="signal-legend" style="margin-bottom: 20px; display: flex; gap: 20px; justify-content: center; font-size: 0.9em; color: var(--text-color); flex-wrap: wrap;">
            <div style="display: flex; align-items: center; gap: 5px;">
                <span style="display: inline-block; width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-bottom: 12px solid #27ae60;"></span>
                <b>BUY:</b> Go Long.
            </div>
            <div style="display: flex; align-items: center; gap: 5px;">
                <span style="display: inline-block; width: 12px; height: 12px; background: #e74c3c; transform: rotate(45deg);"></span>
                <b>SELL:</b> Exit Long.
            </div>
            <div style="display: flex; align-items: center; gap: 5px;">
                <span style="display: inline-block; width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-top: 12px solid #e67e22;"></span>
                <b>SHORT:</b> Go Short (Profit from fall).
            </div>
            <div style="display: flex; align-items: center; gap: 5px;">
                <span style="display: inline-block; width: 12px; height: 12px; background: #9b59b6; border-radius: 50%;"></span>
                <b>COVER:</b> Exit Short.
            </div>
        </div>

        <h2>Trading Ledger</h2>
        <div style="overflow-x:auto;">
            <table id="ledger-table">
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Type</th>
                        <th>Price ($)</th>
                        <th>Amount</th>
                        <th>Value ($)</th>
                        <th>Reason</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>

        <button class="btn btn-secret" onclick="toggleGame()">Play Flappy Bird (Easter Egg)</button>
        <div id="game-container">
            <h2>Flappy Bird</h2>
            <p>Press SPACE or Click to Jump.</p>
            <canvas id="flappyCanvas" width="400" height="500"></canvas>
        </div>

        <footer style="margin-top: 50px; padding-top: 20px; border-top: 1px solid var(--table-border); text-align: center; font-size: 0.8em; color: #777;">
            <p>Data provided by <a href="https://www.coingecko.com/" target="_blank" style="color: var(--accent-color);">CoinGecko</a>.
               Created by <a href="https://github.com/GoogleJules" target="_blank" style="color: var(--accent-color);">Google Jules</a>.</p>
            <p>&copy; 2026 Crypto Trading Simulator</p>
        </footer>
    </div>

    <script>
        async function fetchCryptoData(coinId) {
            const cacheKey = `crypto_data_cache_${coinId}`;
            const cached = localStorage.getItem(cacheKey);
            if (cached) {
                const { timestamp, data } = JSON.parse(cached);
                if (Date.now() - timestamp < 12 * 60 * 60 * 1000) return data;
            }
            try {
                const res = await fetch(`https://api.coingecko.com/api/v3/coins/${coinId}/market_chart?vs_currency=usd&days=365&interval=daily`);
                const data = await res.json();
                const prices = data.prices.map(p => ({ timestamp: p[0], price: p[1] }));
                localStorage.setItem(cacheKey, JSON.stringify({ timestamp: Date.now(), data: prices }));
                return prices;
            } catch (e) { return null; }
        }

        function rollingMean(v, w) {
            return v.map((_, i) => i < w - 1 ? NaN : v.slice(i - w + 1, i + 1).reduce((a, b) => a + b, 0) / w);
        }

        function calculateEMA(v, p) {
            const ema = new Array(v.length).fill(NaN);
            const k = 2 / (p + 1);
            let s = 0, c = 0;
            for (let i = 0; i < v.length; i++) {
                if (!isNaN(v[i])) {
                    if (c < p) { s += v[i]; c++; if (c === p) ema[i] = s / p; }
                    else ema[i] = v[i] * k + ema[i - 1] * (1 - k);
                }
            }
            return ema;
        }

        function calculateRSI(p, n = 14) {
            const rsi = new Array(p.length).fill(NaN);
            if (p.length <= n) return rsi;
            let g = 0, l = 0;
            for (let i = 1; i <= n; i++) {
                const d = p[i] - p[i - 1];
                if (d >= 0) g += d; else l -= d;
            }
            let ag = g / n, al = l / n;
            rsi[n] = al === 0 ? 100 : 100 - (100 / (1 + ag / al));
            for (let i = n + 1; i < p.length; i++) {
                const d = p[i] - p[i - 1];
                ag = (ag * (n - 1) + (d > 0 ? d : 0)) / n;
                al = (al * (n - 1) + (d < 0 ? -d : 0)) / n;
                rsi[i] = 100 - (100 / (1 + ag / al));
            }
            return rsi;
        }

        function calculateStoch(p, n = 14) {
            const k = p.map((_, i) => {
                if (i < n - 1) return NaN;
                const s = p.slice(i - n + 1, i + 1);
                const lo = Math.min(...s), hi = Math.max(...s);
                return ((p[i] - lo) / (hi - lo)) * 100;
            });
            const sk = rollingMean(k, 3);
            return { k: sk, d: rollingMean(sk, 3) };
        }

        function calculateWilliamsR(p, n = 14) {
            return p.map((_, i) => {
                if (i < n - 1) return NaN;
                const s = p.slice(i - n + 1, i + 1);
                const lo = Math.min(...s), hi = Math.max(...s);
                return ((hi - p[i]) / (hi - lo)) * -100;
            });
        }

        function calculateCCI(p, n = 20) {
            const sma = rollingMean(p, n);
            return p.map((v, i) => {
                if (i < n - 1) return NaN;
                const s = p.slice(i - n + 1, i + 1);
                const m = s.reduce((a, b) => a + Math.abs(b - sma[i]), 0) / n;
                return (v - sma[i]) / (0.015 * m);
            });
        }

        function getTradingSignals(pricesData, strategy) {
            const p = pricesData.map(d => d.price);
            const sigs = [];

            if (strategy === 'golden_cross') {
                const m7 = rollingMean(p, 7), m30 = rollingMean(p, 30);
                p.forEach((v, i) => {
                    let a = "HOLD", r = "";
                    if (m7[i] && m30[i] && m7[i-1] && m30[i-1]) {
                        if (m7[i-1] <= m30[i-1] && m7[i] > m30[i]) { a = "BUY"; r = "Fast MA crossed above Slow MA"; }
                        else if (m7[i-1] >= m30[i-1] && m7[i] < m30[i]) { a = "SELL"; r = "Fast MA crossed below Slow MA"; }
                    }
                    sigs.push({ date: pricesData[i].timestamp, price: v, ma7: m7[i], ma30: m30[i], action: a, reason: r });
                });
            } else if (strategy === 'ema_cross') {
                const e12 = calculateEMA(p, 12), e26 = calculateEMA(p, 26);
                p.forEach((v, i) => {
                    let a = "HOLD", r = "";
                    if (e12[i] && e26[i] && e12[i-1] && e26[i-1]) {
                        if (e12[i-1] <= e26[i-1] && e12[i] > e26[i]) { a = "BUY"; r = "EMA 12 crossed above EMA 26"; }
                        else if (e12[i-1] >= e26[i-1] && e12[i] < e26[i]) { a = "SELL"; r = "EMA 12 crossed below EMA 26"; }
                    }
                    sigs.push({ date: pricesData[i].timestamp, price: v, ema12: e12[i], ema26: e26[i], action: a, reason: r });
                });
            } else if (strategy === 'sma_cross') {
                const s50 = rollingMean(p, 50), s200 = rollingMean(p, 200);
                p.forEach((v, i) => {
                    let a = "HOLD", r = "";
                    if (s50[i] && s200[i] && s50[i-1] && s200[i-1]) {
                        if (s50[i-1] <= s200[i-1] && s50[i] > s200[i]) { a = "BUY"; r = "SMA 50 crossed above SMA 200"; }
                        else if (s50[i-1] >= s200[i-1] && s50[i] < s200[i]) { a = "SELL"; r = "SMA 50 crossed below SMA 200"; }
                    }
                    sigs.push({ date: pricesData[i].timestamp, price: v, sma50: s50[i], sma200: s200[i], action: a, reason: r });
                });
            } else if (strategy === 'rsi') {
                const rsi = calculateRSI(p);
                p.forEach((v, i) => {
                    let a = "HOLD", r = "";
                    if (rsi[i] && rsi[i-1]) {
                        if (rsi[i-1] <= 30 && rsi[i] > 30) { a = "BUY"; r = "RSI recovering from oversold"; }
                        else if (rsi[i-1] >= 70 && rsi[i] < 70) { a = "SELL"; r = "RSI falling from overbought"; }
                    }
                    sigs.push({ date: pricesData[i].timestamp, price: v, rsi: rsi[i], action: a, reason: r });
                });
            } else if (strategy === 'macd') {
                const e12 = calculateEMA(p, 12), e26 = calculateEMA(p, 26);
                const macd = e12.map((e, idx) => e - e26[idx]);
                const signal = calculateEMA(macd, 9);
                p.forEach((v, i) => {
                    let a = "HOLD", r = "";
                    if (macd[i] && signal[i] && macd[i-1] && signal[i-1]) {
                        if (macd[i-1] <= signal[i-1] && macd[i] > signal[i]) { a = "BUY"; r = "MACD Bullish crossover"; }
                        else if (macd[i-1] >= signal[i-1] && macd[i] < signal[i]) { a = "SELL"; r = "MACD Bearish crossover"; }
                    }
                    sigs.push({ date: pricesData[i].timestamp, price: v, macd: macd[i], signal: signal[i], action: a, reason: r });
                });
            } else if (strategy === 'stochastic') {
                const { k, d } = calculateStoch(p);
                p.forEach((v, i) => {
                    let a = "HOLD", r = "";
                    if (k[i] && d[i] && k[i-1] && d[i-1]) {
                        if (k[i-1] <= d[i-1] && k[i] > d[i] && k[i] < 20) { a = "BUY"; r = "Stoch Bullish crossover in oversold"; }
                        else if (k[i-1] >= d[i-1] && k[i] < d[i] && k[i] > 80) { a = "SELL"; r = "Stoch Bearish crossover in overbought"; }
                    }
                    sigs.push({ date: pricesData[i].timestamp, price: v, stochK: k[i], stochD: d[i], action: a, reason: r });
                });
            } else if (strategy === 'williams_r') {
                const wr = calculateWilliamsR(p);
                p.forEach((v, i) => {
                    let a = "HOLD", r = "";
                    if (wr[i] && wr[i-1]) {
                        if (wr[i-1] <= -80 && wr[i] > -80) { a = "BUY"; r = "Williams %R recovered from oversold"; }
                        else if (wr[i-1] >= -20 && wr[i] < -20) { a = "SELL"; r = "Williams %R dropped from overbought"; }
                    }
                    sigs.push({ date: pricesData[i].timestamp, price: v, williamsR: wr[i], action: a, reason: r });
                });
            } else if (strategy === 'bollinger') {
                const ma = rollingMean(p, 20);
                const sd = p.map((_, i) => i < 19 ? NaN : Math.sqrt(p.slice(i-19, i+1).reduce((a, b) => a + (b-ma[i])**2, 0)/20));
                const up = ma.map((m, i) => m + 2*sd[i]), lo = ma.map((m, i) => m - 2*sd[i]);
                p.forEach((v, i) => {
                    let a = "HOLD", r = "";
                    if (up[i] && lo[i]) {
                        if (p[i] < lo[i]) { a = "BUY"; r = "Price broke below Lower Band"; }
                        else if (p[i] > up[i]) { a = "SELL"; r = "Price broke above Upper Band"; }
                    }
                    sigs.push({ date: pricesData[i].timestamp, price: v, upper: up[i], lower: lo[i], action: a, reason: r });
                });
            } else if (strategy === 'mean_reversion') {
                const ma = rollingMean(p, 20);
                p.forEach((v, i) => {
                    let a = "HOLD", r = "";
                    if (ma[i]) {
                        if (v < ma[i] * 0.95) { a = "BUY"; r = "Price 5% below 20-day average"; }
                        else if (v > ma[i] * 1.05) { a = "SELL"; r = "Price 5% above 20-day average"; }
                    }
                    sigs.push({ date: pricesData[i].timestamp, price: v, ma20: ma[i], action: a, reason: r });
                });
            } else if (strategy === 'cci') {
                const cci = calculateCCI(p);
                p.forEach((v, i) => {
                    let a = "HOLD", r = "";
                    if (cci[i] && cci[i-1]) {
                        if (cci[i-1] <= -100 && cci[i] > -100) { a = "BUY"; r = "CCI recovered from oversold"; }
                        else if (cci[i-1] >= 100 && cci[i] < 100) { a = "SELL"; r = "CCI dropped from overbought"; }
                    }
                    sigs.push({ date: pricesData[i].timestamp, price: v, cci: cci[i], action: a, reason: r });
                });
            } else if (strategy === 'short_rsi') {
                const rsi = calculateRSI(p);
                p.forEach((v, i) => {
                    let a = "HOLD", r = "";
                    if (rsi[i] && rsi[i-1]) {
                        if (rsi[i-1] >= 70 && rsi[i] < 70) { a = "SHORT"; r = "Entering short as RSI peaks"; }
                        else if (rsi[i-1] <= 30 && rsi[i] > 30) { a = "COVER"; r = "Covering short as RSI bottoms"; }
                    }
                    sigs.push({ date: pricesData[i].timestamp, price: v, rsi: rsi[i], action: a, reason: r });
                });
            } else if (strategy === 'short_macd') {
                const e12 = calculateEMA(p, 12), e26 = calculateEMA(p, 26);
                const macd = e12.map((e, idx) => e - e26[idx]);
                const signal = calculateEMA(macd, 9);
                p.forEach((v, i) => {
                    let a = "HOLD", r = "";
                    if (macd[i] && signal[i] && macd[i-1] && signal[i-1]) {
                        if (macd[i-1] >= signal[i-1] && macd[i] < signal[i]) { a = "SHORT"; r = "Entering short on bearish MACD crossover"; }
                        else if (macd[i-1] <= signal[i-1] && macd[i] > signal[i]) { a = "COVER"; r = "Covering short on bullish MACD crossover"; }
                    }
                    sigs.push({ date: pricesData[i].timestamp, price: v, macd: macd[i], signal: signal[i], action: a, reason: r });
                });
            }
            return sigs;
        }

        class Portfolio {
            constructor(balance, mode, startPrice) {
                this.initVal = mode === 'ACCUMULATE' ? balance * startPrice : balance;
                this.cash = mode === 'ACCUMULATE' ? 0 : balance;
                this.asset = mode === 'ACCUMULATE' ? balance : 0;
                this.ledger = [];
            }
            trade(s) {
                if (s.action === "BUY" && this.cash > 0) {
                    const amt = this.cash / s.price;
                    this.ledger.push({ ...s, amount: amt, value: this.cash });
                    this.asset += amt; this.cash = 0;
                } else if (s.action === "SELL" && this.asset > 0) {
                    const v = this.asset * s.price;
                    this.ledger.push({ ...s, amount: this.asset, value: v });
                    this.cash += v; this.asset = 0;
                } else if (s.action === "SHORT" && this.cash > 0) {
                    if (this.asset > 0) this.trade({ ...s, action: "SELL", reason: "Auto-exit Long" });
                    const amt = this.cash / s.price;
                    this.ledger.push({ ...s, amount: amt, value: this.cash });
                    this.cash *= 2; this.asset -= amt;
                } else if (s.action === "COVER" && this.asset < 0) {
                    const amt = Math.abs(this.asset), cost = amt * s.price;
                    this.ledger.push({ ...s, amount: amt, value: cost });
                    this.cash -= cost; this.asset = 0;
                }
            }
            getValue(p) { return this.cash + this.asset * p; }
        }

        let chart = null;
        async function run() {
            const coin = document.getElementById('crypto-select').value;
            const coinName = document.getElementById('crypto-select').options[document.getElementById('crypto-select').selectedIndex].text.split('(')[1].replace(')', '');
            const strat = document.getElementById('strategy-select').value;
            const mode = document.getElementById('mode-select').value;
            const days = +document.getElementById('period-input').value;
            const bal = +document.getElementById('balance-input').value;

            document.getElementById('balance-label').innerText = mode === 'ACCUMULATE' ? `Initial Balance (${coinName}):` : "Initial Balance ($):";

            const data = await fetchCryptoData(coin);
            if (!data) return;
            const sim = getTradingSignals(data.slice(-days - 200), strat).slice(-days);
            const port = new Portfolio(bal, mode, sim[0].price);
            sim.forEach(s => port.trade(s));

            const finalPrice = sim[sim.length - 1].price;
            const finalVal = port.getValue(finalPrice);
            const profit = finalVal - port.initVal;

            document.getElementById('performance-summary').innerHTML = `
                <div class="stat-card"><h3>Initial Value</h3><p>$${port.initVal.toLocaleString()}</p></div>
                <div class="stat-card"><h3>Final Value</h3><p>$${finalVal.toLocaleString()}</p></div>
                <div class="stat-card"><h3>Profit/Loss</h3><p style="color:${profit>=0?'#27ae60':'#e74c3c'}">$${profit.toLocaleString()} (${((profit/port.initVal)*100).toFixed(2)}%)</p></div>
                <div class="stat-card"><h3>Final Stack</h3><p>${(finalVal/finalPrice).toFixed(4)} ${coinName}</p></div>
            `;
            document.querySelector('#ledger-table tbody').innerHTML = port.ledger.map(t => `
                <tr><td>${new Date(t.date).toLocaleDateString()}</td><td><b>${t.action}</b></td><td>$${t.price.toLocaleString()}</td><td>${t.amount.toFixed(4)}</td><td>$${t.value.toLocaleString()}</td><td>${t.reason}</td></tr>
            `).join('') || '<tr><td colspan="6">No trades.</td></tr>';

            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';

            const datasets = [
                { label: 'Price', data: sim.map(s => s.price), borderColor: isDark ? '#5dade2' : '#3498db', pointRadius: 0, fill: true, backgroundColor: 'rgba(52, 152, 219, 0.1)', order: 2 },
                { label: 'BUY', data: sim.map(s => s.action === 'BUY' ? s.price : null), pointStyle: 'triangle', pointRadius: 8, showLine: false, backgroundColor: '#27ae60', order: 1 },
                { label: 'SELL', data: sim.map(s => s.action === 'SELL' ? s.price : null), pointStyle: 'rectRot', pointRadius: 8, showLine: false, backgroundColor: '#e74c3c', order: 1 },
                { label: 'SHORT', data: sim.map(s => s.action === 'SHORT' ? s.price : null), pointStyle: 'triangle', rotation: 180, pointRadius: 8, showLine: false, backgroundColor: '#e67e22', order: 1 },
                { label: 'COVER', data: sim.map(s => s.action === 'COVER' ? s.price : null), pointStyle: 'circle', pointRadius: 8, showLine: false, backgroundColor: '#9b59b6', order: 1 }
            ];

            const addIndicator = (label, dataKey, color, dashed = true) => {
                const data = sim.map(s => s[dataKey]);
                if (data.some(v => !isNaN(v) && v !== null)) {
                    datasets.push({
                        label, data, borderColor: color, pointRadius: 0, borderWidth: 2,
                        borderDash: dashed ? [5, 5] : [], fill: false, order: 3
                    });
                }
            };

            if (strat === 'golden_cross') { addIndicator('7-Day MA', 'ma7', '#f39c12'); addIndicator('30-Day MA', 'ma30', '#9b59b6'); }
            else if (strat === 'ema_cross') { addIndicator('12-Day EMA', 'ema12', '#f39c12'); addIndicator('26-Day EMA', 'ema26', '#9b59b6'); }
            else if (strat === 'sma_cross') { addIndicator('50-Day SMA', 'sma50', '#f39c12'); addIndicator('200-Day SMA', 'sma200', '#9b59b6'); }
            else if (strat === 'bollinger') { addIndicator('Upper Band', 'upper', '#e67e22'); addIndicator('Lower Band', 'lower', '#e67e22'); }
            else if (strat === 'mean_reversion') { addIndicator('20-Day MA', 'ma20', '#f39c12'); }

            if (chart) chart.destroy();
            chart = new Chart(document.getElementById('priceChart'), {
                type: 'line',
                data: {
                    labels: sim.map(s => new Date(s.date).toLocaleDateString()),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { ticks: { color: isDark ? '#f4f4f4' : '#333' } },
                        y: { ticks: { color: isDark ? '#f4f4f4' : '#333' } }
                    },
                    plugins: {
                        legend: { labels: { color: isDark ? '#f4f4f4' : '#333' } }
                    }
                }
            });

            const strats = {
                golden_cross: '<b>Golden Cross:</b> Uses 7/30 MAs. Best for long-term trends. Why? It filters out noise and catches major market moves.',
                ema_cross: '<b>EMA Cross:</b> 12/26 EMA. Faster response than SMA. Why? Better for reactive traders who want to enter trends early.',
                sma_cross: '<b>SMA Cross:</b> 50/200 SMA. The industry standard. Why? It\'s widely followed by institutions, making it a powerful self-fulfilling prophecy.',
                rsi: '<b>RSI:</b> Relative Strength Index. Why? Identifies over-extended markets. Perfect for "buying the dip" when RSI < 30.',
                macd: '<b>MACD:</b> Trend momentum. Why? Combines trend-following and momentum. Great for confirming a breakout.',
                stochastic: '<b>Stochastic:</b> Why? Faster than RSI, great for sideways markets. It catches cyclical turns.',
                williams_r: '<b>Williams %R:</b> Why? Very sensitive oscillator. Excellent for finding peak/bottom exhaustion.',
                bollinger: '<b>Bollinger Bands:</b> Why? Measures volatility. "The squeeze" predicts big moves; band touches signal reversals.',
                mean_reversion: '<b>Mean Reversion:</b> Why? Markets usually return to the average. Profitable in range-bound environments.',
                cci: '<b>CCI:</b> Why? Identifies new trends and extreme conditions. Very effective in cyclical assets.',
                short_rsi: '<b>Inverse RSI Short:</b> Why? Specifically designed to profit from over-hyped "bubbles" when RSI > 70.',
                short_macd: '<b>MACD Bearish Short:</b> Why? Catches the exact moment bullish momentum dies, allowing you to profit from the crash.'
            };
            document.getElementById('strategy-info').innerHTML = (strats[strat] || '') + '<br><br><b>Shorting:</b> Profiting from a price drop. <b>Cover:</b> Closing a short by buying back.';
        }

        ['crypto-select', 'strategy-select', 'mode-select', 'period-input'].forEach(i => document.getElementById(i).addEventListener('change', run));
        document.getElementById('balance-input').addEventListener('input', run);

        let gameRunning = false;
        const cvs = document.getElementById('flappyCanvas'), c = cvs.getContext('2d');
        let bird = { x: 50, y: 150, w: 20, h: 20, g: 0.08, v: 0, jump: -3.0 };
        let pipes = [], frame = 0, score = 0;
        function toggleGame() {
            document.getElementById('game-container').style.display = document.getElementById('game-container').style.display === 'block' ? 'none' : 'block';
            if (document.getElementById('game-container').style.display === 'block') { reset(); gameRunning = true; loop(); } else gameRunning = false;
        }
        function reset() { bird.y = 150; bird.v = 0; pipes = []; score = 0; frame = 0; }
        function loop() { if (!gameRunning) return; update(); draw(); frame++; requestAnimationFrame(loop); }
        function update() {
            bird.v += bird.g; bird.y += bird.v;
            if (bird.y + bird.h > cvs.height || bird.y < 0) { gameRunning = false; return; }
            if (frame % 180 === 0) { const g = 200, t = Math.random() * (cvs.height - g - 100) + 50; pipes.push({ x: cvs.width, t, b: t + g }); }
            pipes.forEach((p, i) => {
                p.x -= 1.0;
                if (bird.x + bird.w > p.x && bird.x < p.x + 50 && (bird.y < p.t || bird.y + bird.h > p.b)) gameRunning = false;
                if (!p.passed && bird.x > p.x + 50) { score++; p.passed = true; }
                if (p.x + 50 < 0) pipes.splice(i, 1);
            });
        }
        function draw() {
            c.clearRect(0,0,cvs.width,cvs.height);
            c.fillStyle = '#f1c40f'; c.fillRect(bird.x, bird.y, bird.w, bird.h);
            c.fillStyle = '#2ecc71'; pipes.forEach(p => { c.fillRect(p.x, 0, 50, p.t); c.fillRect(p.x, p.b, 50, cvs.height - p.b); });
            c.fillStyle = '#fff'; c.font = '24px Arial'; c.fillText(`Score: ${score}`, 10, 30);
            if (!gameRunning) { c.fillStyle = 'rgba(0,0,0,0.5)'; c.fillRect(0,0,cvs.width,cvs.height); c.fillStyle = '#fff'; c.fillText('RESTART', 150, 250); }
        }
        cvs.addEventListener('mousedown', () => { if (!gameRunning) { reset(); gameRunning = true; loop(); } else bird.v = bird.jump; });
        window.addEventListener('keydown', e => { if (e.code === 'Space') { if (!gameRunning) { reset(); gameRunning = true; loop(); } else bird.v = bird.jump; e.preventDefault(); } });
        function updateThemeIcon() {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const icon = document.getElementById('theme-icon');
            if (isDark) {
                icon.innerHTML = '<path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9c0-.46-.04-.92-.1-1.36-.98 1.37-2.58 2.26-4.4 2.26-2.98 0-5.4-2.42-5.4-5.4 0-1.81.89-3.42 2.26-4.4-.44-.06-.9-.1-1.36-.1z"/>';
            } else {
                icon.innerHTML = '<path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.99 4.58a.996.996 0 00-1.41 0 .996.996 0 000 1.41l1.06 1.06c.39.39 1.03.39 1.41 0s.39-1.03 0-1.41L5.99 4.58zm12.37 12.37a.996.996 0 00-1.41 0 .996.996 0 000 1.41l1.06 1.06c.39.39 1.03.39 1.41 0s.39-1.03 0-1.41l-1.06-1.06zm1.06-10.96a.996.996 0 000-1.41.996.996 0 00-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06zM7.05 18.36a.996.996 0 000-1.41.996.996 0 00-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06z"/>';
            }
        }

        document.getElementById('theme-toggle').addEventListener('click', () => {
            const newTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeIcon();
            run();
        });
        document.documentElement.setAttribute('data-theme', localStorage.getItem('theme') || 'light');
        updateThemeIcon();
        run();
    </script>
</body>
</html>
